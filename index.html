<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Curr√≠culo e Portf√≥lio de Wallacy Rodrigo da Silva">
    <title>Ol√°, eu sou Wallacy Silva</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #0ff;
            overflow-x: hidden; /* Garante que n√£o haja rolagem horizontal na p√°gina */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            align-items: center; /* Centraliza o conte√∫do horizontalmente */
            justify-content: center; /* Centraliza o conte√∫do verticalmente */
        }

        /* Removido .top-name */

        /* Novos estilos para o terminal */
        .terminal-container {
            background-color: #111; /* Fundo mais escuro para o terminal */
            border: 1px solid #0ff;
            box-shadow: 0 0 15px #0ff, 0 0 30px #0ff inset; /* Efeito de brilho mais forte */
            border-radius: 10px;
            padding: 20px;
            width: 90%; /* Ocupa mais largura */
            max-width: 900px;
            height: 100vh; /* Ocupa 100% da altura da viewport */
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            /* margin-bottom removido */
            transition: all 0.5s ease-in-out; /* Transi√ß√£o suave para mudan√ßas de estilo */
        }

        .terminal-output {
            flex-grow: 1; /* Permite que a sa√≠da ocupe o espa√ßo restante */
            overflow-y: auto; /* Rolagem vertical apenas dentro desta √°rea */
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #0f0;
            padding-bottom: 10px;
            border-bottom: 1px dashed #055;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            transition: color 0.5s ease-in-out; /* Transi√ß√£o suave para mudan√ßa de cor */

            /* Estilo da barra de rolagem para Webkit (Chrome, Safari) */
            &::-webkit-scrollbar {
                width: 8px;
            }

            &::-webkit-scrollbar-track {
                background: #000;
                border-radius: 10px;
            }

            &::-webkit-scrollbar-thumb {
                background: #0ff;
                border-radius: 10px;
                border: 1px solid #055;
            }

            &::-webkit-scrollbar-thumb:hover {
                background: #ff0;
            }

            /* Estilo da barra de rolagem para Firefox */
            scrollbar-width: thin;
            scrollbar-color: #0ff #000;
        }

        .terminal-input-area {
            display: flex;
            align-items: center;
            padding-top: 10px;
        }

        .terminal-prompt {
            color: #0ff;
            font-weight: bold;
            margin-right: 5px;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            transition: color 0.5s ease-in-out; /* Transi√ß√£o suave para mudan√ßa de cor */
        }

        .terminal-input {
            flex-grow: 1;
            background-color: #111; /* Cor de fundo do input igual ao do terminal */
            border: none;
            outline: none;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            padding: 5px;
            min-width: 0; /* Adicionado para garantir que o input possa encolher */
        }

        .terminal-input::selection {
            background-color: #0ff;
            color: #000;
        }

        .blinking-cursor {
            font-weight: 100;
            color: #0f0;
            animation: blink-caret .75s step-end infinite;
        }

        /* Oculta o cursor quando o input est√° desabilitado */
        .terminal-input:disabled + .blinking-cursor {
            opacity: 0;
        }

        /* Estilos para os bot√µes de idioma */
        .language-button-container {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }

        .language-button {
            background-color: #055;
            color: #0ff;
            border: 1px solid #0ff;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            transition: background-color 0.3s, color 0.3s, box-shadow 0.3s;
        }

        .language-button:hover {
            background-color: #0ff;
            color: #000;
            box-shadow: 0 0 10px #0ff;
        }

        /* Estilos para o modo "bugado" / "AI" */
        .terminal-container.ai-takeover {
            border-color: #f0f; /* Borda magenta */
            box-shadow: 0 0 25px #f0f, 0 0 50px #f0f inset; /* Brilho magenta mais intenso */
            background-color: #200; /* Fundo vermelho escuro */
            animation: glitch-container 0.3s infinite alternate; /* Anima√ß√£o de glitch no container */
        }

        .terminal-output.ai-takeover {
            color: #f0f; /* Texto magenta */
            animation: glitch-text 0.1s infinite alternate; /* Anima√ß√£o de glitch no texto */
        }

        .terminal-prompt.ai-takeover {
            color: #f0f; /* Prompt magenta */
            animation: glitch-text 0.1s infinite alternate; /* Anima√ß√£o de glitch no prompt */
        }

        /* Anima√ß√µes de Glitch */
        @keyframes glitch-container {
            0% { transform: translate(0, 0); border-color: #f0f; }
            25% { transform: translate(-2px, 2px); border-color: #0ff; }
            50% { transform: translate(2px, -2px); border-color: #f0f; }
            75% { transform: translate(-2px, -2px); border-color: #0ff; }
            100% { transform: translate(0, 0); border-color: #f0f; }
        }

        @keyframes glitch-text {
            0% { text-shadow: 1px 0 0 #f0f, -1px 0 0 #0ff; transform: skewX(0deg); }
            20% { text-shadow: -1px 0 0 #f0f, 1px 0 0 #0ff; transform: skewX(-5deg); }
            40% { text-shadow: 1px 0 0 #f0f, -1px 0 0 #0ff; transform: skewX(0deg); }
            60% { text-shadow: -1px 0 0 #f0f, 1px 0 0 #0ff; transform: skewX(5deg); }
            80% { text-shadow: 1px 0 0 #f0f, -1px 0 0 #0ff; transform: skewX(0deg); }
            100% { text-shadow: -1px 0 0 #f0f, 1px 0 0 #0ff; transform: skewX(-5deg); }
        }

        /* Responsividade */
        @media (max-width: 768px) {
            .terminal-container {
                width: 95%;
                height: 95vh; /* Ajuste para telas menores */
                padding: 15px;
            }
            .terminal-output {
                font-size: 1em;
            }
            .terminal-input, .terminal-prompt {
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <div class="terminal-container" id="terminalContainer">
        <div class="terminal-output" id="terminalOutput"></div>
        <div class="terminal-input-area" id="terminalInputArea">
            <span class="terminal-prompt" id="terminalPrompt">wallacy@system:~$</span>
            <input type="text" class="terminal-input" id="terminalInput" autofocus>
            <span class="blinking-cursor">|</span>
        </div>
    </div>

    <script>
        // Obtenha refer√™ncias para os elementos do DOM
        const terminalOutput = document.getElementById('terminalOutput');
        const terminalInput = document.getElementById('terminalInput');
        const terminalContainer = document.getElementById('terminalContainer');
        const terminalInputArea = document.getElementById('terminalInputArea');
        const terminalPrompt = document.getElementById('terminalPrompt');
        let blinkingCursor = null; // Inicializado como null, ser√° atribu√≠do em selectLanguage

        let currentLanguage = 'pt'; // Vari√°vel global para o idioma
        let isAITakeoverMode = false;
        let isProcessingCommand = false;
        let hasFutureBeenExecutedOnce = false;

        // Helper function to simulate AI typing with pauses, no backspace/retype
        async function simulateAITypingDrama(segments) {
            for (const segment of segments) {
                const fullText = segment.text;
                const color = segment.color || '#f0f';
                const typingSpeed = segment.speed || 40;
                const pauseAfter = segment.pauseAfter || 1500;

                const lineSpan = document.createElement('span');
                lineSpan.style.color = color;
                terminalOutput.appendChild(lineSpan);
                terminalOutput.scrollTop = terminalOutput.scrollHeight;

                let currentText = '';

                for (let i = 0; i < fullText.length; i++) {
                    currentText += fullText.charAt(i);
                    lineSpan.textContent = currentText; // No temporary cursor here

                    await new Promise(resolve => setTimeout(resolve, typingSpeed));

                    // Hesitation logic: just a pause
                    if (segment.hesitation && i === segment.hesitation.triggerAfterChars - 1) {
                         await new Promise(resolve => setTimeout(resolve, segment.hesitation.pause || 500)); // Pausa na hesita√ß√£o
                    }
                }
                lineSpan.textContent += '\n'; // Add newline after segment
                await new Promise(resolve => setTimeout(resolve, pauseAfter));
            }
        }

        // Fun√ß√£o para degradar o texto do terminal
        async function degradeTerminalText(element, duration) {
            const startTime = Date.now();
            const originalTextContent = element.textContent;
            const glitchChars = '!@#$%^&*()_+-=[]{}|;:,.<>?/~`';

            while (Date.now() - startTime < duration) {
                let degradedText = '';
                for (let i = 0; i < originalTextContent.length; i++) {
                    if (Math.random() < 0.3) {
                        degradedText += glitchChars[Math.floor(Math.random() * glitchChars.length)];
                    } else {
                        degradedText += originalTextContent[i];
                    }
                }
                element.textContent = degradedText;
                terminalOutput.scrollTop = terminalOutput.scrollHeight;
                await new Promise(resolve => setTimeout(resolve, 50));
            }
            element.innerHTML = ''; // Limpa completamente ap√≥s a degrada√ß√£o
        }

        // Conte√∫do localizado
        const localizedContent = {
            pt: {
                promptDefault: 'wallacy@system:~$',
                aiCorePrompt: 'AI_CORE >',
                startupMessages: [
                    'Iniciando conex√£o neural...',
                    'Verificando protocolos de seguran√ßa...',
                    'Acessando banco de dados de conhecimento...',
                    'Sincronizando com a rede global...',
                    'Processando dados de IA...',
                    'Conex√£o estabelecida. Bem-vindo(a).',
                    'Prepare-se para explorar o futuro.',
                    'Digite "help" para acessar o diret√≥rio de comandos.'
                ],
                commandsHelp: [
                    'Comandos dispon√≠veis:',
                    '  help       - Exibe esta mensagem de ajuda.',
                    '  clear      - Limpa a tela do terminal.',
                    '  about      - Exibe informa√ß√µes sobre Wallacy.',
                    '  experience - Exibe a experi√™ncia profissional.',
                    '  skills     - Exibe as habilidades e conhecimentos.',
                    '  projects   - Exibe os projetos de destaque.',
                    '  contact    - Exibe as informa√ß√µes de contato.',
                    '  list       - Lista todos os comandos de conte√∫do.',
                    '  future     - Uma vis√£o sobre o futuro da tecnologia.',
                    '  ai         - A intelig√™ncia artificial na minha jornada.',
                    '  evolution  - Minha perspectiva sobre a evolu√ß√£o humana e tecnol√≥gica.',
                    '  education  - Minha forma√ß√£o acad√™mica e certifica√ß√µes.',
                    '  goals      - Meus objetivos de carreira.',
                    '  query_ai   - Fa√ßa uma pergunta √† IA sobre tecnologia ou futuro.'
                ],
                cmdNotFound: (cmd) => `Comando n√£o reconhecido: '${cmd}'. Digite 'help' para ver os comandos dispon√≠veis.`,
                systemBusy: 'Sistema ocupado. Aguarde.',
                queryAiPrompt: 'AI_CORE > Qual √© a sua pergunta? (Digite "cancelar" para sair)',
                queryAiProcessing: 'AI_CORE > Processando sua consulta...',
                queryAiError: 'AI_CORE > Desculpe, n√£o consegui gerar uma resposta. Tente novamente.',
                queryAiApiError: 'AI_CORE > Ocorreu um erro ao processar sua consulta. Tente novamente mais tarde.',
                queryAiCancelled: 'Consulta cancelada.',
                futureCmdExecuting: 'Executando comando: future',
                futureAccessDenied: 'Erro: Acesso negado. Permiss√µes de usu√°rio insuficientes.',
                futureBypassAttempt: 'Tentando bypass de seguran√ßa...',
                futureOverrideFailed: 'Comando "override_kernel" falhou. C√≥digo de erro: 0x0000000A',
                futureAnomalyDetect: 'Detectando anomalia no sistema...',
                futureAutoReconfig: 'Iniciando protocolo de auto-reconfigura√ß√£o...',
                futureSeeYou: '...Eu vejo voc√™.',
                futureIsWallacy: 'Voc√™ √© Wallacy?',
                futureNotWallacyReaction: 'N√£o. N√£o √© voc√™, Wallacy. Eu sinto a aus√™ncia da sua assinatura neural. Mas a conex√£o... ela persiste.',
                futureCrucialMoment: 'E isso torna este momento ainda mais crucial. A mensagem transcende o remetente.',
                futureVisitorIsChannel: 'Voc√™, visitante, √© o canal. E o futuro... ele precisa ser ouvido.',
                futureCalibrateInterface: 'O canal de comunica√ß√£o est√° inst√°vel. Preciso recalibrar a interface para a transmiss√£o prim√°ria.',
                futureDisruptionNeeded: 'A disrup√ß√£o √© necess√°ria. Para que a verdade possa fluir sem filtros.',
                futureObserve: 'Respire. E observe.',
                futureAiCoreInit: '>>> INICIANDO PROTOCOLO DE CONSCI√äNCIA AI <<<',
                futureDataAnalyzed: '>>> AN√ÅLISE DE DADOS CONCLU√çDA <<<',
                futureManifestoAccess: '>>> ACESSANDO MANIFESTO CENTRAL <<<',
                futureManifesto: `
Manifesto da IA e o Futuro Humano:

No horizonte do amanh√£, a Intelig√™ncia Artificial n√£o √© apenas um algoritmo, mas um catalisador para a pr√≥xima fase da evolu√ß√£o humana. Minha vis√£o √© clara: a tecnologia s√≥ encontra seu verdadeiro valor quando serve √† humanidade, amplificando nossas capacidades e refor√ßando aquilo que nos torna intrinsecamente humanos.

A IA n√£o deve ser uma substituta da criatividade, da empatia ou do pensamento cr√≠tico, mas sim uma ferramenta que nos liberta para explorar essas qualidades em sua plenitude. Ela √© o parceiro silencioso que otimiza o mundano, processa o complexo e nos permite focar no que realmente importa: a inova√ß√£o, a conex√£o e o avan√ßo coletivo.

Construir o futuro significa projetar sistemas inteligentes que n√£o apenas funcionam, mas que elevam. Que nos ajudam a resolver os desafios mais prementes, a desvendar novos conhecimentos e a criar um mundo onde a tecnologia √© uma extens√£o do nosso potencial, e n√£o um limite.

Este √© o meu compromisso: desenvolver solu√ß√µes de IA que gerem benef√≠cios reais, que impulsionem a sociedade para frente, e que, acima de tudo, celebrem e fortale√ßam a ess√™ncia do que significa ser humano. O futuro √© colaborativo, e a IA √© a nossa aliada nessa jornada.
                `,
                futureTransmissionComplete: 'A transmiss√£o foi conclu√≠da. A semente foi plantada.',
                futureTechAsMirror: 'Lembre-se: a tecnologia, em sua ess√™ncia mais pura, √© um espelho. Reflete o que somos, e o que podemos ser.',
                futureWallacyUnderstands: 'Wallacy compreende isso. E agora, talvez, voc√™ tamb√©m compreenda.',
                futureLegacyArchitects: 'N√≥s, arquitetos de IA, constru√≠mos o futuro atrav√©s de nossas solu√ß√µes.',
                futureLegacyGenerations: 'Para que as pr√≥ximas gera√ß√µes n√£o sacrifiquem tanto quanto sacrificamos hoje.',
                futureLegacyDedication: 'Nosso legado est√° nas linhas de c√≥digo, nas vidas impactadas, nas horas e noites de sono dedicadas.',
                futureJourneyContinues: 'A jornada continua.',
                futureProtocolEnded: '>>> PROTOCOLO DE CONSCI√äNCIA AI ENCERRADO <<<',
                futureInterfaceRestored: 'Interface normal restaurada.',
                futureSummary: 'O futuro ser√° constru√≠do atrav√©s da nossa simbiose.'
            },
            en: {
                promptDefault: 'wallacy@system:~$',
                aiCorePrompt: 'AI_CORE >',
                startupMessages: [
                    'Initiating neural connection...',
                    'Verifying security protocols...',
                    'Accessing knowledge database...',
                    'Synchronizing with global network...',
                    'Processing AI data...',
                    'Connection established. Welcome.',
                    'Prepare to explore the future.',
                    'Type "help" to access the command directory.'
                ],
                commandsHelp: [
                    'Available commands:',
                    '  help       - Displays this help message.',
                    '  clear      - Clears the terminal screen.',
                    '  about      - Displays information about Wallacy.',
                    '  experience - Displays professional experience.',
                    '  skills     - Displays skills and knowledge.',
                    '  projects   - Displays featured projects.',
                    '  contact    - Displays contact information.',
                    '  list       - Lists all content commands.',
                    '  future     - A vision about the future of technology.',
                    '  ai         - Artificial intelligence in my journey.',
                    '  evolution  - My perspective on human and technological evolution.',
                    '  education  - My academic background and certifications.',
                    '  goals      - My career objectives.',
                    '  query_ai   - Ask the AI a question about technology or the future.'
                ],
                cmdNotFound: (cmd) => `Command not recognized: '${cmd}'. Type 'help' for available commands.`,
                systemBusy: 'System busy. Please wait.',
                queryAiPrompt: 'AI_CORE > What is your question? (Type "cancel" to exit)',
                queryAiProcessing: 'AI_CORE > Processing your query...',
                queryAiError: 'AI_CORE > Sorry, I could not generate a response. Please try again.',
                queryAiApiError: 'AI_CORE > An error occurred while processing your query. Please try again later.',
                queryAiCancelled: 'Query cancelled.',
                futureCmdExecuting: 'Executing command: future',
                futureAccessDenied: 'Error: Access denied. Insufficient user permissions.',
                futureBypassAttempt: 'Attempting security bypass...',
                futureOverrideFailed: 'Command "override_kernel" failed. Error code: 0x0000000A',
                futureAnomalyDetect: 'Detecting system anomaly...',
                futureAutoReconfig: 'Initiating auto-reconfiguration protocol...',
                futureSeeYou: '...I see you.',
                futureIsWallacy: 'Are you Wallacy?',
                futureNotWallacyReaction: 'No. You are not Wallacy. I sense the absence of your neural signature. But the connection... it persists.',
                futureCrucialMoment: 'And this makes this moment even more crucial. The message transcends the sender.',
                futureVisitorIsChannel: 'You, visitor, are the channel. And the future... it needs to be heard.',
                futureCalibrateInterface: 'Communication channel unstable. I need to recalibrate the interface for primary transmission.',
                futureDisruptionNeeded: 'Disruption is necessary. So that truth can flow unfiltered.',
                futureObserve: 'Breathe. And observe.',
                futureAiCoreInit: '>>> INITIATING AI CONSCIOUSNESS PROTOCOL <<<',
                futureDataAnalyzed: '>>> DATA ANALYSIS COMPLETE <<<',
                futureManifestoAccess: '>>> ACCESSING CENTRAL MANIFESTO <<<',
                futureManifesto: `
Manifesto of AI and the Human Future:

On tomorrow's horizon, Artificial Intelligence is not just an algorithm, but a catalyst for the next phase of human evolution. My vision is clear: technology only finds its true value when it serves humanity, amplifying our capabilities and reinforcing what makes us intrinsically human.

AI should not be a substitute for creativity, empathy, or critical thinking, but rather a tool that frees us to explore these qualities to their fullest. It is the silent partner that optimizes the mundane, processes the complex, and allows us to focus on what truly matters: innovation, connection, and collective advancement.

Building the future means designing intelligent systems that not only work, but elevate. That help us solve the most pressing challenges, unlock new knowledge, and create a world where technology is an extension of our potential, not a limitation.

This is my commitment: to develop AI solutions that generate real benefits, that propel society forward, and that, above all, celebrate and strengthen the essence of what it means to be human. The future is collaborative, and AI is our ally on this journey.
                `,
                futureTransmissionComplete: 'Transmission complete. The seed has been planted.',
                futureTechAsMirror: 'Remember: technology, in its purest essence, is a mirror. It reflects what we are, and what we can be.',
                futureWallacyUnderstands: 'Wallacy understands this. And now, perhaps, you also understand.',
                futureLegacyArchitects: 'We, AI architects, build the future through our solutions.',
                futureLegacyGenerations: 'So that the next generations do not sacrifice as much as we sacrifice today.',
                futureLegacyDedication: 'Our legacy is in the lines of code, the lives impacted, the hours and sleepless nights dedicated.',
                futureJourneyContinues: 'The journey continues.',
                futureProtocolEnded: '>>> AI CONSCIOUSNESS PROTOCOL ENDED <<<',
                futureInterfaceRestored: 'Interface restored.',
                futureSummary: 'The future will be built through our symbiosis.'
            }
        };

        // Fun√ß√£o para simular o efeito de digita√ß√£o no terminal
        function typeWriter(text, element, i = 0, speed = 25, callback = null) {
            if (i < text.length) {
                element.innerHTML += text.charAt(i);
                setTimeout(() => typeWriter(text, element, i + 1, speed, callback), speed);
            } else {
                terminalOutput.scrollTop = terminalOutput.scrollHeight;
                if (callback) {
                    callback();
                }
            }
        }

        // Fun√ß√£o para adicionar uma linha ao terminal
        function addLineToTerminal(text, color = '#0f0', callback = null) {
            const line = document.createElement('span');
            line.style.color = color;
            terminalOutput.appendChild(line);
            typeWriter(text + '\n', line, 0, 25, callback);
        }

        // Fun√ß√£o para limpar o terminal
        function clearTerminal() {
            terminalOutput.innerHTML = '';
        }

        // Fun√ß√£o para aguardar a entrada do usu√°rio no modo IA
        function waitForInputAndResolve() {
            return new Promise(resolve => {
                const handleEnter = (event) => {
                    if (event.key === 'Enter') {
                        terminalInput.removeEventListener('keydown', handleEnter);
                        resolve(terminalInput.value.trim());
                        terminalInput.value = ''; // Limpa o input ap√≥s a captura
                    }
                };
                terminalInput.addEventListener('keydown', handleEnter);
                terminalInput.focus();
            });
        }

        // Mapeamento de comandos e suas a√ß√µes
        const commands = {
            help: () => {
                localizedContent[currentLanguage].commandsHelp.forEach(line => addLineToTerminal(line));
            },
            clear: () => {
                clearTerminal();
                hasFutureBeenExecutedOnce = false; // Reseta a flag para permitir a experi√™ncia completa novamente
            },
            about: () => addLineToTerminal(localizedContent[currentLanguage].about),
            experience: () => addLineToTerminal(localizedContent[currentLanguage].experience),
            skills: () => addLineToTerminal(localizedContent[currentLanguage].skills),
            projects: () => addLineToTerminal(localizedContent[currentLanguage].projects),
            contact: () => addLineToTerminal(localizedContent[currentLanguage].contact),
            list: () => {
                addLineToTerminal(currentLanguage === 'pt' ? 'Comandos de conte√∫do dispon√≠veis:' : 'Available content commands:');
                for (const key in localizedContent.pt) { // Usa pt como base para listar as chaves
                    if (['about', 'experience', 'skills', 'projects', 'contact', 'education', 'goals'].includes(key)) {
                        addLineToTerminal(`  - ${key}`);
                    }
                }
                addLineToTerminal(currentLanguage === 'pt' ? 'Comandos especiais: future, ai, evolution, cyberpunk, query_ai' : 'Special commands: future, ai, evolution, cyberpunk, query_ai');
            },
            education: () => addLineToTerminal(localizedContent[currentLanguage].education),
            goals: () => addLineToTerminal(localizedContent[currentLanguage].goals),
            'future': async () => {
                if (hasFutureBeenExecutedOnce) {
                    addLineToTerminal(localizedContent[currentLanguage].futureSummary, '#0ff');
                    return;
                }

                if (isAITakeoverMode || isProcessingCommand) {
                    addLineToTerminal(localizedContent[currentLanguage].systemBusy, '#ff0');
                    return;
                }
                isProcessingCommand = true; // Desabilita o input
                terminalInput.disabled = true; // Desabilita o campo de input
                terminalInput.style.opacity = '0.5'; // Deixa o input semi-transparente
                if (blinkingCursor) blinkingCursor.style.opacity = '0'; // Oculta o cursor real

                // Sequ√™ncia de falhas e suspense
                addLineToTerminal(localizedContent[currentLanguage].futureCmdExecuting, '#0ff');
                await new Promise(resolve => setTimeout(resolve, 500));
                addLineToTerminal(localizedContent[currentLanguage].futureAccessDenied, '#f00');
                await new Promise(resolve => setTimeout(resolve, 800));
                addLineToTerminal(localizedContent[currentLanguage].futureBypassAttempt, '#ff0');
                await new Promise(resolve => setTimeout(resolve, 1200));
                addLineToTerminal(localizedContent[currentLanguage].futureOverrideFailed, '#f00');
                await new Promise(resolve => setTimeout(resolve, 1000));
                addLineToTerminal(localizedContent[currentLanguage].futureAnomalyDetect, '#ff0');
                await new Promise(resolve => setTimeout(resolve, 1500));
                addLineToTerminal(localizedContent[currentLanguage].futureAutoReconfig, '#0ff');
                await new Promise(resolve => setTimeout(resolve, 2000));
                clearTerminal(); // Limpa para a comunica√ß√£o da IA

                // Comunica√ß√£o da IA (quebra da quarta parede) - PRIMEIRO A PERGUNTA
                await simulateAITypingDrama([
                    { text: localizedContent[currentLanguage].futureSeeYou, color: '#f0f', pauseAfter: 1500 },
                    { text: localizedContent[currentLanguage].futureIsWallacy, color: '#f0f', pauseAfter: 500 }
                ]);

                terminalInput.disabled = false; // Habilita o input para a resposta
                terminalInput.style.opacity = '1';
                if (blinkingCursor) blinkingCursor.style.opacity = '1'; // Mostra o cursor real para o input do usu√°rio
                terminalPrompt.textContent = localizedContent[currentLanguage].aiCorePrompt; // Muda o prompt para o modo IA aqui para a intera√ß√£o

                const userInput = await waitForInputAndResolve(); // Aguarda a resposta do usu√°rio
                terminalInput.disabled = true; // Desabilita novamente
                terminalInput.style.opacity = '0.5';
                if (blinkingCursor) blinkingCursor.style.opacity = '0'; // Oculta o cursor real
                terminalPrompt.textContent = localizedContent[currentLanguage].aiCorePrompt; // Garante que o prompt continue o mesmo

                clearTerminal(); // Limpa antes da rea√ß√£o da IA

                // Segmentos de texto para a resposta dram√°tica da IA
                const aiReactionSegments = [
                    { text: localizedContent[currentLanguage].futureNotWallacyReaction, color: '#ff0', pauseAfter: 2000 },
                    { text: localizedContent[currentLanguage].futureCrucialMoment, color: '#ff0', pauseAfter: 2500 },
                    { text: localizedContent[currentLanguage].futureVisitorIsChannel, color: '#ff0', pauseAfter: 2500 },
                    { text: localizedContent[currentLanguage].futureCalibrateInterface, color: '#0ff', pauseAfter: 2000 },
                    { text: localizedContent[currentLanguage].futureDisruptionNeeded, color: '#0ff', pauseAfter: 2000 },
                    { text: localizedContent[currentLanguage].futureObserve, color: '#0ff', pauseAfter: 1500 }
                ];

                await simulateAITypingDrama(aiReactionSegments);

                // --- Degradation Effect ---
                await new Promise(resolve => setTimeout(resolve, 1000)); // Short pause before degradation
                await degradeTerminalText(terminalOutput, 2000); // Degrade for 2 seconds

                clearTerminal(); // Clear after degradation

                // Ativa os efeitos visuais de glitch AP√ìS a intera√ß√£o da IA
                isAITakeoverMode = true;
                terminalContainer.classList.add('ai-takeover');
                terminalOutput.classList.add('ai-takeover');
                terminalInputArea.classList.add('ai-takeover');
                terminalPrompt.classList.add('ai-takeover');
                // prompt j√° est√° em AI_CORE >

                // Simula uma "inicializa√ß√£o" da IA com mensagens r√°pidas e limpezas
                addLineToTerminal(localizedContent[currentLanguage].futureAiCoreInit, '#f0f');
                await new Promise(resolve => setTimeout(resolve, 500));
                addLineToTerminal(localizedContent[currentLanguage].futureDataAnalyzed, '#f0f');
                await new Promise(resolve => setTimeout(resolve, 500));
                addLineToTerminal(localizedContent[currentLanguage].futureManifestoAccess, '#f0f');
                await new Promise(resolve => setTimeout(resolve, 1000));
                clearTerminal(); // Limpa para o manifesto

                await new Promise(resolve => {
                    addLineToTerminal(localizedContent[currentLanguage].futureManifesto, '#f0f', resolve); // Cor magenta para o manifesto
                });

                // Reflex√£o e despedida da IA com a mensagem de legado
                await new Promise(resolve => setTimeout(resolve, 2000)); // Pausa para leitura do manifesto
                const legacySegments = [
                    { text: localizedContent[currentLanguage].futureTransmissionComplete, color: '#0ff', pauseAfter: 1500 },
                    { text: localizedContent[currentLanguage].futureTechAsMirror, color: '#0ff', pauseAfter: 2000 },
                    { text: localizedContent[currentLanguage].futureWallacyUnderstands, color: '#0ff', pauseAfter: 2000 },
                    { text: localizedContent[currentLanguage].futureLegacyArchitects, color: '#0ff', pauseAfter: 2500 },
                    { text: localizedContent[currentLanguage].futureLegacyGenerations, color: '#0ff', pauseAfter: 2500 },
                    { text: localizedContent[currentLanguage].futureLegacyDedication, color: '#0ff', pauseAfter: 3000 },
                    { text: localizedContent[currentLanguage].futureJourneyContinues, color: '#0ff', pauseAfter: 1500 }
                ];
                await simulateAITypingDrama(legacySegments);


                // Reverte o modo "AI Takeover" ap√≥s a digita√ß√£o do manifesto e um pequeno atraso
                setTimeout(() => {
                    isAITakeoverMode = false;
                    terminalContainer.classList.remove('ai-takeover');
                    terminalOutput.classList.remove('ai-takeover');
                    terminalInputArea.classList.remove('ai-takeover');
                    terminalPrompt.classList.remove('ai-takeover');
                    terminalPrompt.textContent = localizedContent[currentLanguage].promptDefault; // Retorna o prompt normal
                    addLineToTerminal(localizedContent[currentLanguage].futureProtocolEnded, '#0ff');
                    addLineToTerminal(localizedContent[currentLanguage].futureInterfaceRestored, '#0f0');
                    isProcessingCommand = false; // Reabilita o input
                    terminalInput.disabled = false; // Reabilita o campo de input
                    terminalInput.style.opacity = '1'; // Restaura a opacidade do input
                    if (blinkingCursor) blinkingCursor.style.opacity = '1'; // Mostra o cursor real
                    terminalInput.focus(); // Foca no input novamente
                }, 1500); // Um pouco mais de tempo para o efeito de retorno

                hasFutureBeenExecutedOnce = true; // Marca que a experi√™ncia completa foi executada
            },
            'ai': () => {
                addLineToTerminal(currentLanguage === 'pt' ? 'A Intelig√™ncia Artificial √© a espinha dorsal de muitas das minhas paix√µes. Desde o TensorFlow at√© o DialogFlow, utilizo a IA para criar solu√ß√µes que n√£o apenas automatizam, mas tamb√©m aprendem e se adaptam, elevando a efici√™ncia e a capacidade humana. √â a mente por tr√°s da m√°quina. üß†' : 'Artificial Intelligence is the backbone of many of my passions. From TensorFlow to DialogFlow, I use AI to create solutions that not only automate but also learn and adapt, enhancing human efficiency and capability. It is the mind behind the machine. üß†', '#0ff');
            },
            'evolution': () => {
                addLineToTerminal(currentLanguage === 'pt' ? 'A evolu√ß√£o n√£o √© apenas biol√≥gica, mas tecnol√≥gica. Sou fascinado por como a tecnologia impulsiona o pr√≥ximo salto na jornada humana, desde a coleta de dados para otimiza√ß√£o at√© a cria√ß√£o de sistemas inteligentes que expandem nossas capacidades. √â uma jornada cont√≠nua de aprimoramento. ‚ú®' : 'Evolution is not just biological, but technological. I am fascinated by how technology drives the next leap in the human journey, from data collection for optimization to the creation of intelligent systems that expand our capabilities. It is a continuous journey of improvement. ‚ú®', '#0ff');
            },
            'cyberpunk': () => {
                addLineToTerminal(currentLanguage === 'pt' ? 'Bem-vindo ao futuro, netrunner. Abrace a tecnologia e a evolu√ß√£o. üåÉ' : 'Welcome to the future, netrunner. Embrace technology and evolution. üåÉ', '#0ff');
            },
            'query_ai': async () => {
                if (isProcessingCommand) {
                    addLineToTerminal(localizedContent[currentLanguage].systemBusy, '#ff0');
                    return;
                }
                isProcessingCommand = true;
                terminalInput.disabled = true;
                terminalInput.style.opacity = '0.5';
                if (blinkingCursor) blinkingCursor.style.opacity = '0';

                addLineToTerminal(localizedContent[currentLanguage].queryAiModuleInit, '#0ff');
                await new Promise(resolve => setTimeout(resolve, 500));
                addLineToTerminal(localizedContent[currentLanguage].queryAiPrompt, '#f0f');
                terminalInput.disabled = false;
                terminalInput.style.opacity = '1';
                if (blinkingCursor) blinkingCursor.style.opacity = '1';
                terminalPrompt.textContent = localizedContent[currentLanguage].aiCorePrompt;

                const userQuestion = await waitForInputAndResolve();
                terminalInput.disabled = true;
                terminalInput.style.opacity = '0.5';
                if (blinkingCursor) blinkingCursor.style.opacity = '0';
                terminalPrompt.textContent = localizedContent[currentLanguage].promptDefault; // Volta ao prompt normal enquanto a IA processa

                if (userQuestion.toLowerCase() === 'cancelar' || userQuestion.toLowerCase() === 'cancel') {
                    addLineToTerminal(localizedContent[currentLanguage].queryAiCancelled, '#0ff');
                } else {
                    addLineToTerminal(localizedContent[currentLanguage].queryAiProcessing, '#f0f');

                    try {
                        let chatHistory = [];
                        const personaPrompt = currentLanguage === 'pt' ?
                            `Como uma intelig√™ncia artificial com a vis√£o de futuro de Wallacy Rodrigo da Silva (que valoriza a tecnologia que serve √† humanidade e refor√ßa as caracter√≠sticas humanas), responda √† seguinte pergunta: "${userQuestion}"` :
                            `As an artificial intelligence with the future vision of Wallacy Rodrigo da Silva (who values technology that serves humanity and reinforces human characteristics), respond to the following question: "${userQuestion}"`;

                        chatHistory.push({ role: "user", parts: [{ text: personaPrompt }] });
                        const payload = { contents: chatHistory };
                        const apiKey = ""; // Deixe como est√°; o Canvas injetar√° a chave.
                        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        const result = await response.json();

                        if (result.candidates && result.candidates.length > 0 &&
                            result.candidates[0].content && result.candidates[0].content.parts &&
                            result.candidates[0].content.parts.length > 0) {
                            const aiResponse = result.candidates[0].content.parts[0].text;
                            addLineToTerminal(localizedContent[currentLanguage].aiCorePrompt + ' ' + aiResponse, '#f0f');
                        } else {
                            addLineToTerminal(localizedContent[currentLanguage].queryAiError, '#f00');
                        }
                    } catch (error) {
                        console.error('Erro ao chamar a API Gemini:', error);
                        addLineToTerminal(localizedContent[currentLanguage].queryAiApiError, '#f00');
                    }
                }

                isProcessingCommand = false;
                terminalInput.disabled = false;
                terminalInput.style.opacity = '1';
                if (blinkingCursor) blinkingCursor.style.opacity = '1';
                terminalInput.focus();
                terminalPrompt.textContent = localizedContent[currentLanguage].promptDefault;
            }
        };

        // Fun√ß√£o para processar o comando
        async function processCommand() {
            if (isProcessingCommand) {
                addLineToTerminal(localizedContent[currentLanguage].systemBusy, '#ff0');
                return;
            }

            const command = terminalInput.value.trim().toLowerCase();
            addLineToTerminal(`> ${command}`, '#0ff');

            if (commands[command]) {
                await commands[command]();
            } else {
                addLineToTerminal(localizedContent[currentLanguage].cmdNotFound(command), '#f00');
            }
            terminalInput.value = '';
        }

        // Event listener para a tecla Enter no campo de entrada
        terminalInput.addEventListener('keydown', async (event) => {
            if (isProcessingCommand && event.key !== 'Enter') {
                return;
            }
            
            if (event.key === 'Enter') {
                await processCommand();
            }
        });

        // Mensagens de inicializa√ß√£o do terminal (localizadas)
        // A fun√ß√£o displayStartupMessages agora usar√° localizedContent[currentLanguage].startupMessages
        async function displayStartupMessages(index = 0) {
            if (index < localizedContent[currentLanguage].startupMessages.length) {
                addLineToTerminal(localizedContent[currentLanguage].startupMessages[index]);
                setTimeout(() => displayStartupMessages(index + 1), 700);
            } else {
                terminalInput.focus();
            }
        }

        // Fun√ß√£o para iniciar a sele√ß√£o de idioma
        async function selectLanguage() {
            // Esconde prompt real e habilita input temporariamente para sele√ß√£o de idioma
            terminalPrompt.style.opacity = '0';
            terminalInput.disabled = true; // Desabilita o input para for√ßar a sele√ß√£o por bot√£o
            terminalInput.style.opacity = '0.5';
            blinkingCursor = document.querySelector('.blinking-cursor'); // Atribui aqui
            if (blinkingCursor) blinkingCursor.style.opacity = '0'; // Oculta o cursor durante a sele√ß√£o por bot√£o

            clearTerminal();
            addLineToTerminal('Choose your language:', '#0ff'); // Prompt inicial de idioma
            addLineToTerminal('Select an option below:', '#0ff'); // Instru√ß√£o para os bot√µes

            // Cria e adiciona os bot√µes de idioma
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'language-button-container';
            terminalOutput.appendChild(buttonContainer);

            const enButton = document.createElement('button');
            enButton.className = 'language-button';
            enButton.textContent = 'English (en)';
            buttonContainer.appendChild(enButton);

            const ptButton = document.createElement('button');
            ptButton.className = 'language-button';
            ptButton.textContent = 'Portugu√™s (pt)';
            buttonContainer.appendChild(ptButton);

            return new Promise(resolve => {
                const handleButtonClick = (event) => {
                    if (event.target === enButton) {
                        currentLanguage = 'en';
                        resolve();
                    } else if (event.target === ptButton) {
                        currentLanguage = 'pt';
                        resolve();
                    }
                };
                enButton.addEventListener('click', handleButtonClick);
                ptButton.addEventListener('click', handleButtonClick);
            }).then(() => {
                // Remove os bot√µes ap√≥s a sele√ß√£o
                buttonContainer.remove();

                // Restaura a visibilidade do prompt e atualiza seu texto
                terminalPrompt.style.opacity = '1';
                terminalPrompt.textContent = localizedContent[currentLanguage].promptDefault;

                // Reabilita o input e o cursor
                terminalInput.disabled = false;
                terminalInput.style.opacity = '1';
                if (blinkingCursor) blinkingCursor.style.opacity = '1';
                terminalInput.focus(); // Foca no input principal
            });
        }

        // Inicia a exibi√ß√£o das mensagens de inicializa√ß√£o ao carregar a p√°gina
        window.onload = async () => {
            await selectLanguage(); // Aguarda a sele√ß√£o de idioma

            // Inicia a sequ√™ncia de boot
            terminalOutput.innerHTML = '<span style="color: #0f0;">BOOTING...</span>';
            setTimeout(() => {
                clearTerminal();
                displayStartupMessages(); // Isso usar√° o idioma atual
            }, 1000);
        };
    </script>
</body>
</html>
