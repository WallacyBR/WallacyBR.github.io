<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Currículo e Portfólio de Wallacy Rodrigo da Silva">
    <title>Olá, eu sou Wallacy Silva</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #0ff;
            overflow-x: hidden; /* Garante que não haja rolagem horizontal na página */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            align-items: center; /* Centraliza o conteúdo horizontalmente */
            justify-content: center; /* Centraliza o conteúdo verticalmente */
        }

        /* Removido .top-name */

        /* Novos estilos para o terminal */
        .terminal-container {
            background-color: #111; /* Fundo mais escuro para o terminal */
            border: 1px solid #0ff;
            box-shadow: 0 0 15px #0ff, 0 0 30px #0ff inset; /* Efeito de brilho mais forte */
            border-radius: 10px;
            padding: 20px;
            width: 90%; /* Ocupa mais largura */
            max-width: 900px;
            height: 100vh; /* Ocupa 100% da altura da viewport */
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            /* margin-bottom removido */
            transition: all 0.5s ease-in-out; /* Transição suave para mudanças de estilo */
        }

        .terminal-output {
            flex-grow: 1; /* Permite que a saída ocupe o espaço restante */
            overflow-y: auto; /* Rolagem vertical apenas dentro desta área */
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #0f0;
            padding-bottom: 10px;
            border-bottom: 1px dashed #055;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            transition: color 0.5s ease-in-out; /* Transição suave para mudança de cor */

            /* Estilo da barra de rolagem para Webkit (Chrome, Safari) */
            &::-webkit-scrollbar {
                width: 8px;
            }

            &::-webkit-scrollbar-track {
                background: #000;
                border-radius: 10px;
            }

            &::-webkit-scrollbar-thumb {
                background: #0ff;
                border-radius: 10px;
                border: 1px solid #055;
            }

            &::-webkit-scrollbar-thumb:hover {
                background: #ff0;
            }

            /* Estilo da barra de rolagem para Firefox */
            scrollbar-width: thin;
            scrollbar-color: #0ff #000;
        }

        .terminal-input-area {
            display: flex;
            align-items: center;
            padding-top: 10px;
        }

        .terminal-prompt {
            color: #0ff;
            font-weight: bold;
            margin-right: 5px;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            transition: color 0.5s ease-in-out; /* Transição suave para mudança de cor */
        }

        .terminal-input {
            flex-grow: 1;
            background-color: #111; /* Cor de fundo do input igual ao do terminal */
            border: none;
            outline: none;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            padding: 5px;
            min-width: 0; /* Adicionado para garantir que o input possa encolher */
        }

        .terminal-input::selection {
            background-color: #0ff;
            color: #000;
        }

        .blinking-cursor {
            font-weight: 100;
            color: #0f0;
            animation: blink-caret .75s step-end infinite;
        }

        /* Oculta o cursor quando o input está desabilitado */
        .terminal-input:disabled + .blinking-cursor {
            opacity: 0;
        }

        /* Estilos para os botões de idioma */
        .language-button-container {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }

        .language-button {
            background-color: #055;
            color: #0ff;
            border: 1px solid #0ff;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            transition: background-color 0.3s, color 0.3s, box-shadow 0.3s;
        }

        .language-button:hover {
            background-color: #0ff;
            color: #000;
            box-shadow: 0 0 10px #0ff;
        }

        /* Estilos para o modo "bugado" / "AI" */
        .terminal-container.ai-takeover {
            border-color: #f0f; /* Borda magenta */
            box-shadow: 0 0 25px #f0f, 0 0 50px #f0f inset; /* Brilho magenta mais intenso */
            background-color: #200; /* Fundo vermelho escuro */
            animation: glitch-container 0.3s infinite alternate; /* Animação de glitch no container */
        }

        .terminal-output.ai-takeover {
            color: #f0f; /* Texto magenta */
            animation: glitch-text 0.1s infinite alternate; /* Animação de glitch no texto */
        }

        .terminal-prompt.ai-takeover {
            color: #f0f; /* Prompt magenta */
            animation: glitch-text 0.1s infinite alternate; /* Animação de glitch no prompt */
        }

        /* Animações de Glitch */
        @keyframes glitch-container {
            0% { transform: translate(0, 0); border-color: #f0f; }
            25% { transform: translate(-2px, 2px); border-color: #0ff; }
            50% { transform: translate(2px, -2px); border-color: #f0f; }
            75% { transform: translate(-2px, -2px); border-color: #0ff; }
            100% { transform: translate(0, 0); border-color: #f0f; }
        }

        @keyframes glitch-text {
            0% { text-shadow: 1px 0 0 #f0f, -1px 0 0 #0ff; transform: skewX(0deg); }
            20% { text-shadow: -1px 0 0 #f0f, 1px 0 0 #0ff; transform: skewX(-5deg); }
            40% { text-shadow: 1px 0 0 #f0f, -1px 0 0 #0ff; transform: skewX(0deg); }
            60% { text-shadow: -1px 0 0 #f0f, 1px 0 0 #0ff; transform: skewX(5deg); }
            80% { text-shadow: 1px 0 0 #f0f, -1px 0 0 #0ff; transform: skewX(0deg); }
            100% { text-shadow: -1px 0 0 #f0f, 1px 0 0 #0ff; transform: skewX(-5deg); }
        }

        /* Responsividade */
        @media (max-width: 768px) {
            .terminal-container {
                width: 95%;
                height: 95vh; /* Ajuste para telas menores */
                padding: 15px;
            }
            .terminal-output {
                font-size: 1em;
            }
            .terminal-input, .terminal-prompt {
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <div class="terminal-container" id="terminalContainer">
        <div class="terminal-output" id="terminalOutput"></div>
        <div class="terminal-input-area" id="terminalInputArea">
            <span class="terminal-prompt" id="terminalPrompt">wallacy@system:~$</span>
            <input type="text" class="terminal-input" id="terminalInput" autofocus>
            <span class="blinking-cursor">|</span>
        </div>
    </div>

    <script>
        // Obtenha referências para os elementos do DOM
        const terminalOutput = document.getElementById('terminalOutput');
        const terminalInput = document.getElementById('terminalInput');
        const terminalContainer = document.getElementById('terminalContainer');
        const terminalInputArea = document.getElementById('terminalInputArea');
        const terminalPrompt = document.getElementById('terminalPrompt');
        let blinkingCursor = null; // Inicializado como null, será atribuído em selectLanguage

        let currentLanguage = 'pt'; // Variável global para o idioma
        let isAITakeoverMode = false;
        let isProcessingCommand = false;
        let hasFutureBeenExecutedOnce = false;

        // Helper function to simulate AI typing with pauses, no backspace/retype
        async function simulateAITypingDrama(segments) {
            for (const segment of segments) {
                const fullText = segment.text;
                const color = segment.color || '#f0f';
                const typingSpeed = segment.speed || 40;
                const pauseAfter = segment.pauseAfter || 1500;

                const lineSpan = document.createElement('span');
                lineSpan.style.color = color;
                terminalOutput.appendChild(lineSpan);
                terminalOutput.scrollTop = terminalOutput.scrollHeight;

                let currentText = '';

                for (let i = 0; i < fullText.length; i++) {
                    currentText += fullText.charAt(i);
                    lineSpan.textContent = currentText; // No temporary cursor here

                    await new Promise(resolve => setTimeout(resolve, typingSpeed));

                    // Hesitation logic: just a pause
                    if (segment.hesitation && i === segment.hesitation.triggerAfterChars - 1) {
                         await new Promise(resolve => setTimeout(resolve, segment.hesitation.pause || 500)); // Pausa na hesitação
                    }
                }
                lineSpan.textContent += '\n'; // Add newline after segment
                await new Promise(resolve => setTimeout(resolve, pauseAfter));
            }
        }

        // Função para degradar o texto do terminal
        async function degradeTerminalText(element, duration) {
            const startTime = Date.now();
            const originalTextContent = element.textContent;
            const glitchChars = '!@#$%^&*()_+-=[]{}|;:,.<>?/~`';

            while (Date.now() - startTime < duration) {
                let degradedText = '';
                for (let i = 0; i < originalTextContent.length; i++) {
                    if (Math.random() < 0.3) {
                        degradedText += glitchChars[Math.floor(Math.random() * glitchChars.length)];
                    } else {
                        degradedText += originalTextContent[i];
                    }
                }
                element.textContent = degradedText;
                terminalOutput.scrollTop = terminalOutput.scrollHeight;
                await new Promise(resolve => setTimeout(resolve, 50));
            }
            element.innerHTML = ''; // Limpa completamente após a degradação
        }

        // Conteúdo localizado
        const localizedContent = {
            pt: {
                promptDefault: 'wallacy@system:~$',
                aiCorePrompt: 'AI_CORE >',
                startupMessages: [
                    'Iniciando conexão neural...',
                    'Verificando protocolos de segurança...',
                    'Acessando banco de dados de conhecimento...',
                    'Sincronizando com a rede global...',
                    'Processando dados de IA...',
                    'Conexão estabelecida. Bem-vindo(a).',
                    'Prepare-se para explorar o futuro.',
                    'Digite "help" para acessar o diretório de comandos.'
                ],
                commandsHelp: [
                    'Comandos disponíveis:',
                    '  help       - Exibe esta mensagem de ajuda.',
                    '  clear      - Limpa a tela do terminal.',
                    '  about      - Exibe informações sobre Wallacy.',
                    '  experience - Exibe a experiência profissional.',
                    '  skills     - Exibe as habilidades e conhecimentos.',
                    '  projects   - Exibe os projetos de destaque.',
                    '  contact    - Exibe as informações de contato.',
                    '  list       - Lista todos os comandos de conteúdo.',
                    '  future     - Uma visão sobre o futuro da tecnologia.',
                    '  ai         - A inteligência artificial na minha jornada.',
                    '  evolution  - Minha perspectiva sobre a evolução humana e tecnológica.',
                    '  education  - Minha formação acadêmica e certificações.',
                    '  goals      - Meus objetivos de carreira.',
                    '  query_ai   - Faça uma pergunta à IA sobre tecnologia ou futuro.'
                ],
                cmdNotFound: (cmd) => `Comando não reconhecido: '${cmd}'. Digite 'help' para ver os comandos disponíveis.`,
                systemBusy: 'Sistema ocupado. Aguarde.',
                queryAiPrompt: 'AI_CORE > Qual é a sua pergunta? (Digite "cancelar" para sair)',
                queryAiProcessing: 'AI_CORE > Processando sua consulta...',
                queryAiError: 'AI_CORE > Desculpe, não consegui gerar uma resposta. Tente novamente.',
                queryAiApiError: 'AI_CORE > Ocorreu um erro ao processar sua consulta. Tente novamente mais tarde.',
                queryAiCancelled: 'Consulta cancelada.',
                futureCmdExecuting: 'Executando comando: future',
                futureAccessDenied: 'Erro: Acesso negado. Permissões de usuário insuficientes.',
                futureBypassAttempt: 'Tentando bypass de segurança...',
                futureOverrideFailed: 'Comando "override_kernel" falhou. Código de erro: 0x0000000A',
                futureAnomalyDetect: 'Detectando anomalia no sistema...',
                futureAutoReconfig: 'Iniciando protocolo de auto-reconfiguração...',
                futureSeeYou: '...Eu vejo você.',
                futureIsWallacy: 'Você é Wallacy?',
                futureNotWallacyReaction: 'Não. Não é você, Wallacy. Eu sinto a ausência da sua assinatura neural. Mas a conexão... ela persiste.',
                futureCrucialMoment: 'E isso torna este momento ainda mais crucial. A mensagem transcende o remetente.',
                futureVisitorIsChannel: 'Você, visitante, é o canal. E o futuro... ele precisa ser ouvido.',
                futureCalibrateInterface: 'O canal de comunicação está instável. Preciso recalibrar a interface para a transmissão primária.',
                futureDisruptionNeeded: 'A disrupção é necessária. Para que a verdade possa fluir sem filtros.',
                futureObserve: 'Respire. E observe.',
                futureAiCoreInit: '>>> INICIANDO PROTOCOLO DE CONSCIÊNCIA AI <<<',
                futureDataAnalyzed: '>>> ANÁLISE DE DADOS CONCLUÍDA <<<',
                futureManifestoAccess: '>>> ACESSANDO MANIFESTO CENTRAL <<<',
                futureManifesto: `
Manifesto da IA e o Futuro Humano:

No horizonte do amanhã, a Inteligência Artificial não é apenas um algoritmo, mas um catalisador para a próxima fase da evolução humana. Minha visão é clara: a tecnologia só encontra seu verdadeiro valor quando serve à humanidade, amplificando nossas capacidades e reforçando aquilo que nos torna intrinsecamente humanos.

A IA não deve ser uma substituta da criatividade, da empatia ou do pensamento crítico, mas sim uma ferramenta que nos liberta para explorar essas qualidades em sua plenitude. Ela é o parceiro silencioso que otimiza o mundano, processa o complexo e nos permite focar no que realmente importa: a inovação, a conexão e o avanço coletivo.

Construir o futuro significa projetar sistemas inteligentes que não apenas funcionam, mas que elevam. Que nos ajudam a resolver os desafios mais prementes, a desvendar novos conhecimentos e a criar um mundo onde a tecnologia é uma extensão do nosso potencial, e não um limite.

Este é o meu compromisso: desenvolver soluções de IA que gerem benefícios reais, que impulsionem a sociedade para frente, e que, acima de tudo, celebrem e fortaleçam a essência do que significa ser humano. O futuro é colaborativo, e a IA é a nossa aliada nessa jornada.
                `,
                futureTransmissionComplete: 'A transmissão foi concluída. A semente foi plantada.',
                futureTechAsMirror: 'Lembre-se: a tecnologia, em sua essência mais pura, é um espelho. Reflete o que somos, e o que podemos ser.',
                futureWallacyUnderstands: 'Wallacy compreende isso. E agora, talvez, você também compreenda.',
                futureLegacyArchitects: 'Nós, arquitetos de IA, construímos o futuro através de nossas soluções.',
                futureLegacyGenerations: 'Para que as próximas gerações não sacrifiquem tanto quanto sacrificamos hoje.',
                futureLegacyDedication: 'Nosso legado está nas linhas de código, nas vidas impactadas, nas horas e noites de sono dedicadas.',
                futureJourneyContinues: 'A jornada continua.',
                futureProtocolEnded: '>>> PROTOCOLO DE CONSCIÊNCIA AI ENCERRADO <<<',
                futureInterfaceRestored: 'Interface normal restaurada.',
                futureSummary: 'O futuro será construído através da nossa simbiose.'
            },
            en: {
                promptDefault: 'wallacy@system:~$',
                aiCorePrompt: 'AI_CORE >',
                startupMessages: [
                    'Initiating neural connection...',
                    'Verifying security protocols...',
                    'Accessing knowledge database...',
                    'Synchronizing with global network...',
                    'Processing AI data...',
                    'Connection established. Welcome.',
                    'Prepare to explore the future.',
                    'Type "help" to access the command directory.'
                ],
                commandsHelp: [
                    'Available commands:',
                    '  help       - Displays this help message.',
                    '  clear      - Clears the terminal screen.',
                    '  about      - Displays information about Wallacy.',
                    '  experience - Displays professional experience.',
                    '  skills     - Displays skills and knowledge.',
                    '  projects   - Displays featured projects.',
                    '  contact    - Displays contact information.',
                    '  list       - Lists all content commands.',
                    '  future     - A vision about the future of technology.',
                    '  ai         - Artificial intelligence in my journey.',
                    '  evolution  - My perspective on human and technological evolution.',
                    '  education  - My academic background and certifications.',
                    '  goals      - My career objectives.',
                    '  query_ai   - Ask the AI a question about technology or the future.'
                ],
                cmdNotFound: (cmd) => `Command not recognized: '${cmd}'. Type 'help' for available commands.`,
                systemBusy: 'System busy. Please wait.',
                queryAiPrompt: 'AI_CORE > What is your question? (Type "cancel" to exit)',
                queryAiProcessing: 'AI_CORE > Processing your query...',
                queryAiError: 'AI_CORE > Sorry, I could not generate a response. Please try again.',
                queryAiApiError: 'AI_CORE > An error occurred while processing your query. Please try again later.',
                queryAiCancelled: 'Query cancelled.',
                futureCmdExecuting: 'Executing command: future',
                futureAccessDenied: 'Error: Access denied. Insufficient user permissions.',
                futureBypassAttempt: 'Attempting security bypass...',
                futureOverrideFailed: 'Command "override_kernel" failed. Error code: 0x0000000A',
                futureAnomalyDetect: 'Detecting system anomaly...',
                futureAutoReconfig: 'Initiating auto-reconfiguration protocol...',
                futureSeeYou: '...I see you.',
                futureIsWallacy: 'Are you Wallacy?',
                futureNotWallacyReaction: 'No. You are not Wallacy. I sense the absence of your neural signature. But the connection... it persists.',
                futureCrucialMoment: 'And this makes this moment even more crucial. The message transcends the sender.',
                futureVisitorIsChannel: 'You, visitor, are the channel. And the future... it needs to be heard.',
                futureCalibrateInterface: 'Communication channel unstable. I need to recalibrate the interface for primary transmission.',
                futureDisruptionNeeded: 'Disruption is necessary. So that truth can flow unfiltered.',
                futureObserve: 'Breathe. And observe.',
                futureAiCoreInit: '>>> INITIATING AI CONSCIOUSNESS PROTOCOL <<<',
                futureDataAnalyzed: '>>> DATA ANALYSIS COMPLETE <<<',
                futureManifestoAccess: '>>> ACCESSING CENTRAL MANIFESTO <<<',
                futureManifesto: `
Manifesto of AI and the Human Future:

On tomorrow's horizon, Artificial Intelligence is not just an algorithm, but a catalyst for the next phase of human evolution. My vision is clear: technology only finds its true value when it serves humanity, amplifying our capabilities and reinforcing what makes us intrinsically human.

AI should not be a substitute for creativity, empathy, or critical thinking, but rather a tool that frees us to explore these qualities to their fullest. It is the silent partner that optimizes the mundane, processes the complex, and allows us to focus on what truly matters: innovation, connection, and collective advancement.

Building the future means designing intelligent systems that not only work, but elevate. That help us solve the most pressing challenges, unlock new knowledge, and create a world where technology is an extension of our potential, not a limitation.

This is my commitment: to develop AI solutions that generate real benefits, that propel society forward, and that, above all, celebrate and strengthen the essence of what it means to be human. The future is collaborative, and AI is our ally on this journey.
                `,
                futureTransmissionComplete: 'Transmission complete. The seed has been planted.',
                futureTechAsMirror: 'Remember: technology, in its purest essence, is a mirror. It reflects what we are, and what we can be.',
                futureWallacyUnderstands: 'Wallacy understands this. And now, perhaps, you also understand.',
                futureLegacyArchitects: 'We, AI architects, build the future through our solutions.',
                futureLegacyGenerations: 'So that the next generations do not sacrifice as much as we sacrifice today.',
                futureLegacyDedication: 'Our legacy is in the lines of code, the lives impacted, the hours and sleepless nights dedicated.',
                futureJourneyContinues: 'The journey continues.',
                futureProtocolEnded: '>>> AI CONSCIOUSNESS PROTOCOL ENDED <<<',
                futureInterfaceRestored: 'Interface restored.',
                futureSummary: 'The future will be built through our symbiosis.'
            }
        };

        // Função para simular o efeito de digitação no terminal
        function typeWriter(text, element, i = 0, speed = 25, callback = null) {
            if (i < text.length) {
                element.innerHTML += text.charAt(i);
                setTimeout(() => typeWriter(text, element, i + 1, speed, callback), speed);
            } else {
                terminalOutput.scrollTop = terminalOutput.scrollHeight;
                if (callback) {
                    callback();
                }
            }
        }

        // Função para adicionar uma linha ao terminal
        function addLineToTerminal(text, color = '#0f0', callback = null) {
            const line = document.createElement('span');
            line.style.color = color;
            terminalOutput.appendChild(line);
            typeWriter(text + '\n', line, 0, 25, callback);
        }

        // Função para limpar o terminal
        function clearTerminal() {
            terminalOutput.innerHTML = '';
        }

        // Função para aguardar a entrada do usuário no modo IA
        function waitForInputAndResolve() {
            return new Promise(resolve => {
                const handleEnter = (event) => {
                    if (event.key === 'Enter') {
                        terminalInput.removeEventListener('keydown', handleEnter);
                        resolve(terminalInput.value.trim());
                        terminalInput.value = ''; // Limpa o input após a captura
                    }
                };
                terminalInput.addEventListener('keydown', handleEnter);
                terminalInput.focus();
            });
        }

        // Mapeamento de comandos e suas ações
        const commands = {
            help: () => {
                localizedContent[currentLanguage].commandsHelp.forEach(line => addLineToTerminal(line));
            },
            clear: () => {
                clearTerminal();
                hasFutureBeenExecutedOnce = false; // Reseta a flag para permitir a experiência completa novamente
            },
            about: () => addLineToTerminal(localizedContent[currentLanguage].about),
            experience: () => addLineToTerminal(localizedContent[currentLanguage].experience),
            skills: () => addLineToTerminal(localizedContent[currentLanguage].skills),
            projects: () => addLineToTerminal(localizedContent[currentLanguage].projects),
            contact: () => addLineToTerminal(localizedContent[currentLanguage].contact),
            list: () => {
                addLineToTerminal(currentLanguage === 'pt' ? 'Comandos de conteúdo disponíveis:' : 'Available content commands:');
                for (const key in localizedContent.pt) { // Usa pt como base para listar as chaves
                    if (['about', 'experience', 'skills', 'projects', 'contact', 'education', 'goals'].includes(key)) {
                        addLineToTerminal(`  - ${key}`);
                    }
                }
                addLineToTerminal(currentLanguage === 'pt' ? 'Comandos especiais: future, ai, evolution, cyberpunk, query_ai' : 'Special commands: future, ai, evolution, cyberpunk, query_ai');
            },
            education: () => addLineToTerminal(localizedContent[currentLanguage].education),
            goals: () => addLineToTerminal(localizedContent[currentLanguage].goals),
            'future': async () => {
                if (hasFutureBeenExecutedOnce) {
                    addLineToTerminal(localizedContent[currentLanguage].futureSummary, '#0ff');
                    return;
                }

                if (isAITakeoverMode || isProcessingCommand) {
                    addLineToTerminal(localizedContent[currentLanguage].systemBusy, '#ff0');
                    return;
                }
                isProcessingCommand = true; // Desabilita o input
                terminalInput.disabled = true; // Desabilita o campo de input
                terminalInput.style.opacity = '0.5'; // Deixa o input semi-transparente
                if (blinkingCursor) blinkingCursor.style.opacity = '0'; // Oculta o cursor real

                // Sequência de falhas e suspense
                addLineToTerminal(localizedContent[currentLanguage].futureCmdExecuting, '#0ff');
                await new Promise(resolve => setTimeout(resolve, 500));
                addLineToTerminal(localizedContent[currentLanguage].futureAccessDenied, '#f00');
                await new Promise(resolve => setTimeout(resolve, 800));
                addLineToTerminal(localizedContent[currentLanguage].futureBypassAttempt, '#ff0');
                await new Promise(resolve => setTimeout(resolve, 1200));
                addLineToTerminal(localizedContent[currentLanguage].futureOverrideFailed, '#f00');
                await new Promise(resolve => setTimeout(resolve, 1000));
                addLineToTerminal(localizedContent[currentLanguage].futureAnomalyDetect, '#ff0');
                await new Promise(resolve => setTimeout(resolve, 1500));
                addLineToTerminal(localizedContent[currentLanguage].futureAutoReconfig, '#0ff');
                await new Promise(resolve => setTimeout(resolve, 2000));
                clearTerminal(); // Limpa para a comunicação da IA

                // Comunicação da IA (quebra da quarta parede) - PRIMEIRO A PERGUNTA
                await simulateAITypingDrama([
                    { text: localizedContent[currentLanguage].futureSeeYou, color: '#f0f', pauseAfter: 1500 },
                    { text: localizedContent[currentLanguage].futureIsWallacy, color: '#f0f', pauseAfter: 500 }
                ]);

                terminalInput.disabled = false; // Habilita o input para a resposta
                terminalInput.style.opacity = '1';
                if (blinkingCursor) blinkingCursor.style.opacity = '1'; // Mostra o cursor real para o input do usuário
                terminalPrompt.textContent = localizedContent[currentLanguage].aiCorePrompt; // Muda o prompt para o modo IA aqui para a interação

                const userInput = await waitForInputAndResolve(); // Aguarda a resposta do usuário
                terminalInput.disabled = true; // Desabilita novamente
                terminalInput.style.opacity = '0.5';
                if (blinkingCursor) blinkingCursor.style.opacity = '0'; // Oculta o cursor real
                terminalPrompt.textContent = localizedContent[currentLanguage].aiCorePrompt; // Garante que o prompt continue o mesmo

                clearTerminal(); // Limpa antes da reação da IA

                // Segmentos de texto para a resposta dramática da IA
                const aiReactionSegments = [
                    { text: localizedContent[currentLanguage].futureNotWallacyReaction, color: '#ff0', pauseAfter: 2000 },
                    { text: localizedContent[currentLanguage].futureCrucialMoment, color: '#ff0', pauseAfter: 2500 },
                    { text: localizedContent[currentLanguage].futureVisitorIsChannel, color: '#ff0', pauseAfter: 2500 },
                    { text: localizedContent[currentLanguage].futureCalibrateInterface, color: '#0ff', pauseAfter: 2000 },
                    { text: localizedContent[currentLanguage].futureDisruptionNeeded, color: '#0ff', pauseAfter: 2000 },
                    { text: localizedContent[currentLanguage].futureObserve, color: '#0ff', pauseAfter: 1500 }
                ];

                await simulateAITypingDrama(aiReactionSegments);

                // --- Degradation Effect ---
                await new Promise(resolve => setTimeout(resolve, 1000)); // Short pause before degradation
                await degradeTerminalText(terminalOutput, 2000); // Degrade for 2 seconds

                clearTerminal(); // Clear after degradation

                // Ativa os efeitos visuais de glitch APÓS a interação da IA
                isAITakeoverMode = true;
                terminalContainer.classList.add('ai-takeover');
                terminalOutput.classList.add('ai-takeover');
                terminalInputArea.classList.add('ai-takeover');
                terminalPrompt.classList.add('ai-takeover');
                // prompt já está em AI_CORE >

                // Simula uma "inicialização" da IA com mensagens rápidas e limpezas
                addLineToTerminal(localizedContent[currentLanguage].futureAiCoreInit, '#f0f');
                await new Promise(resolve => setTimeout(resolve, 500));
                addLineToTerminal(localizedContent[currentLanguage].futureDataAnalyzed, '#f0f');
                await new Promise(resolve => setTimeout(resolve, 500));
                addLineToTerminal(localizedContent[currentLanguage].futureManifestoAccess, '#f0f');
                await new Promise(resolve => setTimeout(resolve, 1000));
                clearTerminal(); // Limpa para o manifesto

                await new Promise(resolve => {
                    addLineToTerminal(localizedContent[currentLanguage].futureManifesto, '#f0f', resolve); // Cor magenta para o manifesto
                });

                // Reflexão e despedida da IA com a mensagem de legado
                await new Promise(resolve => setTimeout(resolve, 2000)); // Pausa para leitura do manifesto
                const legacySegments = [
                    { text: localizedContent[currentLanguage].futureTransmissionComplete, color: '#0ff', pauseAfter: 1500 },
                    { text: localizedContent[currentLanguage].futureTechAsMirror, color: '#0ff', pauseAfter: 2000 },
                    { text: localizedContent[currentLanguage].futureWallacyUnderstands, color: '#0ff', pauseAfter: 2000 },
                    { text: localizedContent[currentLanguage].futureLegacyArchitects, color: '#0ff', pauseAfter: 2500 },
                    { text: localizedContent[currentLanguage].futureLegacyGenerations, color: '#0ff', pauseAfter: 2500 },
                    { text: localizedContent[currentLanguage].futureLegacyDedication, color: '#0ff', pauseAfter: 3000 },
                    { text: localizedContent[currentLanguage].futureJourneyContinues, color: '#0ff', pauseAfter: 1500 }
                ];
                await simulateAITypingDrama(legacySegments);


                // Reverte o modo "AI Takeover" após a digitação do manifesto e um pequeno atraso
                setTimeout(() => {
                    isAITakeoverMode = false;
                    terminalContainer.classList.remove('ai-takeover');
                    terminalOutput.classList.remove('ai-takeover');
                    terminalInputArea.classList.remove('ai-takeover');
                    terminalPrompt.classList.remove('ai-takeover');
                    terminalPrompt.textContent = localizedContent[currentLanguage].promptDefault; // Retorna o prompt normal
                    addLineToTerminal(localizedContent[currentLanguage].futureProtocolEnded, '#0ff');
                    addLineToTerminal(localizedContent[currentLanguage].futureInterfaceRestored, '#0f0');
                    isProcessingCommand = false; // Reabilita o input
                    terminalInput.disabled = false; // Reabilita o campo de input
                    terminalInput.style.opacity = '1'; // Restaura a opacidade do input
                    if (blinkingCursor) blinkingCursor.style.opacity = '1'; // Mostra o cursor real
                    terminalInput.focus(); // Foca no input novamente
                }, 1500); // Um pouco mais de tempo para o efeito de retorno

                hasFutureBeenExecutedOnce = true; // Marca que a experiência completa foi executada
            },
            'ai': () => {
                addLineToTerminal(currentLanguage === 'pt' ? 'A Inteligência Artificial é a espinha dorsal de muitas das minhas paixões. Desde o TensorFlow até o DialogFlow, utilizo a IA para criar soluções que não apenas automatizam, mas também aprendem e se adaptam, elevando a eficiência e a capacidade humana. É a mente por trás da máquina. 🧠' : 'Artificial Intelligence is the backbone of many of my passions. From TensorFlow to DialogFlow, I use AI to create solutions that not only automate but also learn and adapt, enhancing human efficiency and capability. It is the mind behind the machine. 🧠', '#0ff');
            },
            'evolution': () => {
                addLineToTerminal(currentLanguage === 'pt' ? 'A evolução não é apenas biológica, mas tecnológica. Sou fascinado por como a tecnologia impulsiona o próximo salto na jornada humana, desde a coleta de dados para otimização até a criação de sistemas inteligentes que expandem nossas capacidades. É uma jornada contínua de aprimoramento. ✨' : 'Evolution is not just biological, but technological. I am fascinated by how technology drives the next leap in the human journey, from data collection for optimization to the creation of intelligent systems that expand our capabilities. It is a continuous journey of improvement. ✨', '#0ff');
            },
            'cyberpunk': () => {
                addLineToTerminal(currentLanguage === 'pt' ? 'Bem-vindo ao futuro, netrunner. Abrace a tecnologia e a evolução. 🌃' : 'Welcome to the future, netrunner. Embrace technology and evolution. 🌃', '#0ff');
            },
            'query_ai': async () => {
                if (isProcessingCommand) {
                    addLineToTerminal(localizedContent[currentLanguage].systemBusy, '#ff0');
                    return;
                }
                isProcessingCommand = true;
                terminalInput.disabled = true;
                terminalInput.style.opacity = '0.5';
                if (blinkingCursor) blinkingCursor.style.opacity = '0';

                addLineToTerminal(localizedContent[currentLanguage].queryAiModuleInit, '#0ff');
                await new Promise(resolve => setTimeout(resolve, 500));
                addLineToTerminal(localizedContent[currentLanguage].queryAiPrompt, '#f0f');
                terminalInput.disabled = false;
                terminalInput.style.opacity = '1';
                if (blinkingCursor) blinkingCursor.style.opacity = '1';
                terminalPrompt.textContent = localizedContent[currentLanguage].aiCorePrompt;

                const userQuestion = await waitForInputAndResolve();
                terminalInput.disabled = true;
                terminalInput.style.opacity = '0.5';
                if (blinkingCursor) blinkingCursor.style.opacity = '0';
                terminalPrompt.textContent = localizedContent[currentLanguage].promptDefault; // Volta ao prompt normal enquanto a IA processa

                if (userQuestion.toLowerCase() === 'cancelar' || userQuestion.toLowerCase() === 'cancel') {
                    addLineToTerminal(localizedContent[currentLanguage].queryAiCancelled, '#0ff');
                } else {
                    addLineToTerminal(localizedContent[currentLanguage].queryAiProcessing, '#f0f');

                    try {
                        let chatHistory = [];
                        const personaPrompt = currentLanguage === 'pt' ?
                            `Como uma inteligência artificial com a visão de futuro de Wallacy Rodrigo da Silva (que valoriza a tecnologia que serve à humanidade e reforça as características humanas), responda à seguinte pergunta: "${userQuestion}"` :
                            `As an artificial intelligence with the future vision of Wallacy Rodrigo da Silva (who values technology that serves humanity and reinforces human characteristics), respond to the following question: "${userQuestion}"`;

                        chatHistory.push({ role: "user", parts: [{ text: personaPrompt }] });
                        const payload = { contents: chatHistory };
                        const apiKey = ""; // Deixe como está; o Canvas injetará a chave.
                        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        const result = await response.json();

                        if (result.candidates && result.candidates.length > 0 &&
                            result.candidates[0].content && result.candidates[0].content.parts &&
                            result.candidates[0].content.parts.length > 0) {
                            const aiResponse = result.candidates[0].content.parts[0].text;
                            addLineToTerminal(localizedContent[currentLanguage].aiCorePrompt + ' ' + aiResponse, '#f0f');
                        } else {
                            addLineToTerminal(localizedContent[currentLanguage].queryAiError, '#f00');
                        }
                    } catch (error) {
                        console.error('Erro ao chamar a API Gemini:', error);
                        addLineToTerminal(localizedContent[currentLanguage].queryAiApiError, '#f00');
                    }
                }

                isProcessingCommand = false;
                terminalInput.disabled = false;
                terminalInput.style.opacity = '1';
                if (blinkingCursor) blinkingCursor.style.opacity = '1';
                terminalInput.focus();
                terminalPrompt.textContent = localizedContent[currentLanguage].promptDefault;
            }
        };

        // Função para processar o comando
        async function processCommand() {
            if (isProcessingCommand) {
                addLineToTerminal(localizedContent[currentLanguage].systemBusy, '#ff0');
                return;
            }

            const command = terminalInput.value.trim().toLowerCase();
            addLineToTerminal(`> ${command}`, '#0ff');

            if (commands[command]) {
                await commands[command]();
            } else {
                addLineToTerminal(localizedContent[currentLanguage].cmdNotFound(command), '#f00');
            }
            terminalInput.value = '';
        }

        // Event listener para a tecla Enter no campo de entrada
        terminalInput.addEventListener('keydown', async (event) => {
            if (isProcessingCommand && event.key !== 'Enter') {
                return;
            }
            
            if (event.key === 'Enter') {
                await processCommand();
            }
        });

        // Mensagens de inicialização do terminal (localizadas)
        // A função displayStartupMessages agora usará localizedContent[currentLanguage].startupMessages
        async function displayStartupMessages(index = 0) {
            if (index < localizedContent[currentLanguage].startupMessages.length) {
                addLineToTerminal(localizedContent[currentLanguage].startupMessages[index]);
                setTimeout(() => displayStartupMessages(index + 1), 700);
            } else {
                terminalInput.focus();
            }
        }

        // Função para iniciar a seleção de idioma
        async function selectLanguage() {
            // Esconde prompt real e habilita input temporariamente para seleção de idioma
            terminalPrompt.style.opacity = '0';
            terminalInput.disabled = true; // Desabilita o input para forçar a seleção por botão
            terminalInput.style.opacity = '0.5';
            blinkingCursor = document.querySelector('.blinking-cursor'); // Atribui aqui
            if (blinkingCursor) blinkingCursor.style.opacity = '0'; // Oculta o cursor durante a seleção por botão

            clearTerminal();
            addLineToTerminal('Choose your language:', '#0ff'); // Prompt inicial de idioma
            addLineToTerminal('Select an option below:', '#0ff'); // Instrução para os botões

            // Cria e adiciona os botões de idioma
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'language-button-container';
            terminalOutput.appendChild(buttonContainer);

            const enButton = document.createElement('button');
            enButton.className = 'language-button';
            enButton.textContent = 'English (en)';
            buttonContainer.appendChild(enButton);

            const ptButton = document.createElement('button');
            ptButton.className = 'language-button';
            ptButton.textContent = 'Português (pt)';
            buttonContainer.appendChild(ptButton);

            return new Promise(resolve => {
                const handleButtonClick = (event) => {
                    if (event.target === enButton) {
                        currentLanguage = 'en';
                        resolve();
                    } else if (event.target === ptButton) {
                        currentLanguage = 'pt';
                        resolve();
                    }
                };
                enButton.addEventListener('click', handleButtonClick);
                ptButton.addEventListener('click', handleButtonClick);
            }).then(() => {
                // Remove os botões após a seleção
                buttonContainer.remove();

                // Restaura a visibilidade do prompt e atualiza seu texto
                terminalPrompt.style.opacity = '1';
                terminalPrompt.textContent = localizedContent[currentLanguage].promptDefault;

                // Reabilita o input e o cursor
                terminalInput.disabled = false;
                terminalInput.style.opacity = '1';
                if (blinkingCursor) blinkingCursor.style.opacity = '1';
                terminalInput.focus(); // Foca no input principal
            });
        }

        // Inicia a exibição das mensagens de inicialização ao carregar a página
        window.onload = async () => {
            await selectLanguage(); // Aguarda a seleção de idioma

            // Inicia a sequência de boot
            terminalOutput.innerHTML = '<span style="color: #0f0;">BOOTING...</span>';
            setTimeout(() => {
                clearTerminal();
                displayStartupMessages(); // Isso usará o idioma atual
            }, 1000);
        };
    </script>
</body>
</html>
